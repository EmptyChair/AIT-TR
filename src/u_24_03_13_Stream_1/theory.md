## 01. Лямбда-выражения и функциональные интерфейсы
* Оказывается, что в ОЗУ сохраняются не только переменные, но и методы.
* Это значит (то что методы тоже лежат в памяти), что на них можно делать ссылки.
* Чтобы получить метод как значение, которое можно записать в переменную, нужно указать имя класса, а потом
  оператор разрешения областей видимости `::` (scope resolution operator).
* Это значение будет называться ссылкой на метод (method reference).
* Это значение теперь можно записать в переменную.
* Тип переменной, в которую можно записать эту ссылку будет функциональным интерфейсом
* Функциональный интерфейс - это такой интерфейс, у которого есть всего один не реализованный метод, и он (интерфейс)
  аннотирован как `@FunctionalInterface`
* Для методов с разными конфигурациями возвращаемых значений и параметров существуют разные функциональные интерфейсы.
* Например, для методов которые ничего не принимают и ничего не возвращают используется Runnable

* Лямбда-выражения (ЛВ) - они же анонимные функции - это такие методы, которые определены внутри выполняемых блоков кода.
* ЛВ не могут существовать сами по себе, они обязательно должны быть записаны в переменную типа функционального интерфейса.
* ЛВ выполняются не при определении, а при вызове из переменной.
* Так как ЛВ можно передавать как переменные в другие методы, это, по сути, является способом передавать недостающие
  куски кода в другие методы.
* Синтаксис:
```
(параметры) -> {выполняемый код}
```
* Обратите внимание, что "->" это два символа, "тире" и "знак больше"

* Основные функциональные интерфейсы в Java:
    * Runnable - ЛВ которые не возвращают и не принимают ничего
    * Supplier - ЛВ которые ничего не принимают, но что-то возвращают
    * Consumer - ЛВ которые что-то принимают, но ничего не возвращают
    * Function - ЛВ которые принимают один параметр, и что-то возвращают
    * Predicate - ЛВ которые принимают один параметр и возвращают boolean
    * Comparator - ЛВ которое принимает два параметра и сравнивает их. Возвращает 1, 0 или -1 в зависимости
      от результата сравнения. 1 если первый объект больше второго, 0 если они равны, -1 если второй больше первого

## 02. Stream API
* API - Application programming interface - такой набор классов, который позволяет вам взаимодействовать с чем-то.

* Отличия конвейера от коллекции:
  * Элементы не хранятся
  * Неявная итерация
  * Функциональный стиль — операции не меняют источник
  * Большинство операций работают с λ-выражениями
  * Ленивое выполнение - то есть выполнение пойдёт не раньше терминальной команды
  * Экземпляр, стрима нельзя использовать более одного раза =( ;
  * Возможность неограниченного числа элементов
  
* StreamAPI - Библиотека в джаве, которая позволяет очень быстро и удобно обрабатывать данные.
  * Эта библиотека может заменить десятки строк на одну инструкцию.
  * Но при этом эта инструкция все равно будет занимать несколько строк.
  * Основные свойства:
    * конвейерная обработка данных, при этом в роли конвейера - последовательность операций
    * поток - последовательность элементов
    * поток может быть последовательным или параллельным 
* Основным классом Stream API является Stream - поток объектов.
* В этом потоке объектов, над ними можно делать различные манипуляции:

* Создание:
    * .stream() у любой коллекции - создает поток и кладет в него все элементы коллекции.
      * list.stream()
      * map.entrySet().stream()
      * Collection.stream()
      * Arrays.stream(Object[]) - Создает поток и добавляет в него все элементы переданного массива.
    * Stream.of(1,2,3) - Создает поток из всех элементов, которые будут сюда переданы.
    * IntStream.range(int, int) 
    * Files.lines(Path), BufferedReader.lines()
    * Random.ints()
    * Stream.empty() - пустрой стрим
    * Stream.generate(Supplier<T> s)
    * Stream.iterate(T seed, UnaryOperator<T> f)
  
* Обработка данных (промежуточные операции, intermediate operations, lazy):
    * filter - принимает предикат, удаляет все элементы из потока, которые не подходят (предикат для них вернул false).
    * limit - принимает число и ограничивает количество элементов потока до этого числа (обрезает).
    * map - принимает функцию, которая преобразовывает один объект в другой. Таким образом можно поменять обобщенный тип потока.
    * distinct - удаляет все дубликаты.
    * sorted - сортирует поток по натуральному порядку, либо по предоставленному компаратору.
    * skip - принимает число и удаляет такое количетсво элементов с начала.
    * dropWhile - принимает предикат, и удаляет с начала все элементы, пока для них предикат возвращает false
    * peek - принимает потребителя (Consumer) и выполняет его на каждом элементе.
    * flatMap - "уравнивает" поток из коллекций, так, чтобы после этого в потоке были только элементы самих коллекций

    * промежуточные операции бывают 
      * stateless (выполняются вне зависимости от других элементов) - filter, map, flatmap, peek
      * stateful (в зависимости от др. элементов, как сортировка) - distinct, sorted, limit, skip
      
* Сбор данных (терминальные операции, terminal operations, eager):
    * long count - возвращет количество элементов в потоке, на котором он был вызван
    * int/long/double sum возвращет сумму элементов в потоке, на котором он был вызван
    * forEach - делает тоже самое что и peek, только при этом завершает работу потока (возвращает void).
    * forEachOrdered - то же самое, но гарантирует сохранение порядка элементов (возвращает void).
    * reduce - уменьшает весь поток до одного элемента, правило уменьшения задается переданной функцией
    * anyMatch - возвращает true, если хотябы один элемент совпадает с переданным предикатом
    * allMatch - возвращает true, если все элементы дают true с переданным предикатом
    * noneMatch - возвращает true, если все элементы дают false с переданным предикатом
    * max/min - возвращает максимальное/минимальное значение (по переданному компаратору)
    * collect - принимает коллектор, возвращает поток как коллекцию
    * findFirst - достаёт первый элемент
    * toList - возвращает поток как обычный список (с 16 версии джавы)
    * toSet
    * summingInt(ToIntFunction mapper), summingLong(ToLongFunction mapper), summingDouble(ToDoubleFunction mapper) — 
      коллектор, который преобразовывает объекты в int/long/double и подсчитывает сумму.
    * OptionalInt, OptionalLong, OptionalDouble
      * int getAsInt(), long getAsLong(), double getAsDouble()    

* Построение конвейера:
* long count = words.stream().filter(s->s.length()>5).count();
  * источник (стрим с источником данных)               :  words.stream()
  * промежуточные операции (от 0 до нескольких)        :  .filter(s->s.length()>5)
  * терминальная операция (одна)                       :  count()


